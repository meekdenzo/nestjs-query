"use strict";(self.webpackChunknestjs_query=self.webpackChunknestjs_query||[]).push([[2853],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>y});var o=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,o,s=function(e,t){if(null==e)return{};var n,o,s={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var c=o.createContext({}),d=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return o.createElement(c.Provider,{value:t},e.children)},l="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,c=e.parentName,p=a(e,["components","mdxType","originalType","parentName"]),l=d(n),u=s,y=l["".concat(c,".").concat(u)]||l[u]||m[u]||r;return n?o.createElement(y,i(i({ref:t},p),{},{components:n})):o.createElement(y,i({ref:t},p))}));function y(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,i=new Array(r);i[0]=u;var a={};for(var c in t)hasOwnProperty.call(t,c)&&(a[c]=t[c]);a.originalType=e,a[l]="string"==typeof e?e:s,i[1]=a;for(var d=2;d<r;d++)i[d]=n[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2884:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>c,default:()=>y,frontMatter:()=>a,metadata:()=>d,toc:()=>l});var o=n(7462),s=n(3366),r=(n(7294),n(3905)),i=["components"],a={title:"Testing Services"},c=void 0,d={unversionedId:"persistence/typeorm/testing-services",id:"persistence/typeorm/testing-services",title:"Testing Services",description:"It is possible to test services that use TypeOrmQueryService. The process is similar to the one described for nestjs, but it has a few differences.",source:"@site/docs/persistence/typeorm/testing-services.md",sourceDirName:"persistence/typeorm",slug:"/persistence/typeorm/testing-services",permalink:"/nestjs-query/docs/persistence/typeorm/testing-services",draft:!1,editUrl:"https://github.com/tripss/nestjs-query/edit/master/documentation/docs/persistence/typeorm/testing-services.md",tags:[],version:"current",frontMatter:{title:"Testing Services"},sidebar:"docs",previous:{title:"Soft Delete",permalink:"/nestjs-query/docs/persistence/typeorm/soft-delete"},next:{title:"Getting Started",permalink:"/nestjs-query/docs/persistence/sequelize/getting-started"}},p={},l=[{value:"Mocking Inherited Methods",id:"mocking-inherited-methods",level:2}],m={toc:l},u="wrapper";function y(e){var t=e.components,n=(0,s.Z)(e,i);return(0,r.kt)(u,(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"It is possible to test services that use ",(0,r.kt)("inlineCode",{parentName:"p"},"TypeOrmQueryService"),". The process is similar to the one described for ",(0,r.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/techniques/database#testing"},"nestjs"),", but it has a few differences."),(0,r.kt)("p",null,"Let's assume we have the following ",(0,r.kt)("inlineCode",{parentName:"p"},"TodoItem")," service. For the sake of completeness, let's also add a dependency on another service (let's pretend that the todos have subTasks; we are not using relationships here):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todo-item.service.ts"',title:'"todo-item.service.ts"'},"import { InjectQueryService, QueryService } from '@ptc-org/nestjs-query-core';\nimport { TypeOrmQueryService } from '@ptc-org/nestjs-query-typeorm';\nimport { Repository } from 'typeorm';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { SubTaskEntity } from '../sub-task/sub-task.entity';\nimport { TodoItemEntity } from './todo-item.entity';\n\n@QueryService(TodoItemEntity)\nexport class TodoItemService extends TypeOrmQueryService<TodoItemEntity> {\n  constructor(\n    @InjectRepository(TodoItemEntity) private todosRepository: Repository<TodoItemEntity>,\n    @InjectQueryService(SubTaskEntity) private subTaskService: QueryService<SubTaskEntity>,\n  ) {\n    super(todosRepository);\n  }\n\n  async getWithSubTasks(id: number): Promise<{ todoItem: TodoItemEntity; subTasks: SubTaskEntity[] }> {\n    const todoItem = await this.todosRepository.findOneOrFail(id);\n    const subTasks = await this.subTaskService.query({ filter: { todoItemId: { eq: id } } });\n    return { todoItem, subTasks };\n  }\n}\n\n")),(0,r.kt)("p",null,"Now lets write some tests! "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todo-item.service.spec.ts"',title:'"todo-item.service.spec.ts"'},"import { Test, TestingModule } from '@nestjs/testing';\nimport { getQueryServiceToken } from '@ptc-org/nestjs-query-core';\nimport { getRepositoryToken } from '@nestjs/typeorm';\nimport { plainToClass } from 'class-transformer';\nimport { TodoItemEntity } from '../src/todo-item/todo-item.entity';\nimport { SubTaskEntity } from '../src/sub-task/sub-task.entity';\nimport { TodoItemService } from '../src/todo-item/todo-item.service';\n\n// We create some fake entiites, just for testing. Here they are empty,\n// but they can be more complex, depending on the testing cases.\nconst subTasks = [new SubTaskEntity(), new SubTaskEntity(), new SubTaskEntity()];\nconst oneTodo: TodoItemEntity = plainToClass(TodoItemEntity, { id: 1, title: 'A test todo' });\n\ndescribe('TodosItemService', () => {\n  let service: TodoItemService; // Removed type, compared to the nestjs examples\n\n  // We mock the responses of the two services. \n  // The mocks in this example are very simple, but they can be more complex, depending on the test cases.\n\n  const mockedSubTaskService = {\n    // mock the query method that is used by getWithSubTasks\n    query: jest.fn((query) => Promise.resolve(subTasks)),\n  };  \n  const mockedRepo = {\n    // mock the repo `findOneOrFail`\n    findOneOrFail: jest.fn((id) => Promise.resolve(oneTodo)),\n  };\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        // Provide the original service\n        TodoItemService,\n        // Mock the repository using the `getRepositoryToken` from @nestjs/typeorm\n        {\n          provide: getRepositoryToken(TodoItemEntity),\n          useValue: mockedRepo,\n        },\n        // Mock the SubTask QueryService using the `getQueryServiceToken` from @ptc-org/nestjs-query-core\n        {\n          provide: getQueryServiceToken(SubTaskEntity),\n          useValue: mockedSubTaskService,\n        },\n      ],\n    }).compile();\n    // get the service from the testing module.\n    service = await module.get(TodoItemService);\n  });\n\n  // reset call counts and called with arguments after each spec\n  afterEach(() => jest.clearAllMocks());\n\n  // Now we are ready to write the tests.\n  describe('getWithSubTasks', () => {\n    it('should return a TodoItem with subTasks', async () => {\n      // We can use jest spies to inspect if functions are called ...\n\n      // create a spy for the repository findOneOrFail method\n      const findOneOrFailSpy = jest.spyOn(mockedRepo, 'findOneOrFail');\n      // create a spy for the mocked subTaskService query method\n      const querySpy = jest.spyOn(mockedSubTaskService, 'query');\n\n      // When we call a service function the following things happen:\n      // - the real service function is called, so we can test its code\n      // - the mocked repository method is called\n      // - the mocked subTask query service method is called\n      // note that if the service calls a function in a repo or query service that is not defined by a mock, the test\n      // will fail\n      const todo = await service.getWithSubTasks(oneTodo.id);\n      // check the result against the expected results\n      expect(todo).toEqual({ todoItem: oneTodo, subTasks });\n\n      // Ensure that the spies are called once with the appropriate arguments\n      expect(findOneOrFailSpy).toHaveBeenCalledTimes(1);\n      expect(findOneOrFailSpy).toHaveBeenCalledWith(oneTodo.id);\n      expect(querySpy).toHaveBeenCalledTimes(1);\n      expect(querySpy).toHaveBeenCalledWith({ filter: { todoItemId: { eq: oneTodo.id } } });\n    });\n  });\n});\n\n")),(0,r.kt)("h2",{id:"mocking-inherited-methods"},"Mocking Inherited Methods"),(0,r.kt)("p",null,"You can also mock inherited methods."),(0,r.kt)("p",null,"Let's change the ",(0,r.kt)("inlineCode",{parentName:"p"},"getWithSubTasks")," method from the ",(0,r.kt)("inlineCode",{parentName:"p"},"TodoItemService")," to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"getById")," method from the parent ",(0,r.kt)("inlineCode",{parentName:"p"},"TypeOrmQueryService")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"async getWithSubTasks(id: number): Promise<{ todoItem: TodoItemEntity; subTasks: SubTaskEntity[] }> {\n  const todoItem = await this.getById(id);\n  const subTasks = await this.subTaskService.query({ filter: { todoItemId: { eq: id } } });\n  return { todoItem, subTasks };\n}\n")),(0,r.kt)("p",null,"To mock the ",(0,r.kt)("inlineCode",{parentName:"p"},"getById")," method we can create a new ",(0,r.kt)("inlineCode",{parentName:"p"},"spy")," with a mock implementation"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const getByIdSpy = jest.spyOn(service, 'getById').mockImplementation(() => Promise.resolve(oneTodo));\n")),(0,r.kt)("p",null,"Lets update our tests to mock out the ",(0,r.kt)("inlineCode",{parentName:"p"},"getById")," implementation"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"describe('getWithSubTasks', () => {\n  it('should return a TodoItem with subTasks', async () => {\n    // We can use jest spies to inspect if functions are called ...\n\n    // create a mock implementation for getById on the service\n    const getByIdSpy = jest.spyOn(service, 'getById').mockImplementation(() => Promise.resolve(oneTodo));\n    // create a spy for the mocked subTaskService query method\n    const querySpy = jest.spyOn(mockedSubTaskService, 'query');\n\n    // When we call a service function the following things happen:\n    // - the real service function is called, so we can test its code\n    // - the mock todoItem query service method is called\n    // - the mocked subTask query service method is called\n    // note that if the service calls a function in a repo or query service that is not defined by a mock, the test\n    // will fail\n    const todo = await service.getWithSubTasks(oneTodo.id);\n    // check the result against the expected results\n    expect(todo).toEqual({ todoItem: oneTodo, subTasks });\n\n    // Ensure that the spies are called once with the appropriate arguments\n    expect(getByIdSpy).toHaveBeenCalledTimes(1);\n    expect(getByIdSpy).toHaveBeenCalledWith(oneTodo.id);\n    expect(querySpy).toHaveBeenCalledTimes(1);\n    expect(querySpy).toHaveBeenCalledWith({ filter: { todoItemId: { eq: oneTodo.id } } });\n  });\n\n  it('should reject if the getById rejects with an error', async () => {\n    // We can use jest spies to inspect if functions are called ...\n\n    // create a mock implementation for the service getById method\n    const getByIdSpy = jest.spyOn(service, 'getById').mockImplementation(() => Promise.reject(new Error('foo')));\n    // create a spy for the mocked subTaskService query method\n    const querySpy = jest.spyOn(mockedSubTaskService, 'query');\n\n    // When we call a service function the following things happen:\n    // - the real service function is called, so we can test its code\n    // - the mocked repository method is called\n    // - the mocked subTask query service method is called\n    // note that if the service calls a function in a repo or query service that is not defined by a mock, the test\n    // will fail\n    await expect(service.getWithSubTasks(oneTodo.id)).rejects.toThrow('foo');\n\n    // Ensure that the getById spy is called one\n    expect(getByIdSpy).toHaveBeenCalledTimes(1);\n    expect(getByIdSpy).toHaveBeenCalledWith(oneTodo.id);\n    // Ensure that that the querySpy was not called  \n    expect(querySpy).not.toHaveBeenCalled();\n  });\n});\n")))}y.isMDXComponent=!0}}]);