"use strict";(self.webpackChunknestjs_query=self.webpackChunknestjs_query||[]).push([[9772],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=r.createContext({}),s=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=s(e.components);return r.createElement(u.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,u=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=s(n),c=o,h=p["".concat(u,".").concat(c)]||p[c]||m[c]||a;return n?r.createElement(h,i(i({ref:t},d),{},{components:n})):r.createElement(h,i({ref:t},d))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=c;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[p]="string"==typeof e?e:o,i[1]=l;for(var s=2;s<a;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>i});var r=n(7294),o=n(4334);const a={tabItem:"tabItem_Ymn6"};function i(e){var t=e.children,n=e.hidden,i=e.className;return r.createElement("div",{role:"tabpanel",className:(0,o.Z)(a.tabItem,i),hidden:n},t)}},4866:(e,t,n)=>{n.d(t,{Z:()=>T});var r=n(7462),o=n(7294),a=n(4334),i=n(2466),l=n(6550),u=n(1980),s=n(7392),d=n(12);function p(e){return function(e){var t,n;return null!=(t=null==(n=o.Children.map(e,(function(e){if(!e||(0,o.isValidElement)(e)&&(t=e.props)&&"object"==typeof t&&"value"in t)return e;var t;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:n.filter(Boolean))?t:[]}(e).map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes,default:t.default}}))}function m(e){var t=e.values,n=e.children;return(0,o.useMemo)((function(){var e=null!=t?t:p(n);return function(e){var t=(0,s.l)(e,(function(e,t){return e.value===t.value}));if(t.length>0)throw new Error('Docusaurus error: Duplicate values "'+t.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[t,n])}function c(e){var t=e.value;return e.tabValues.some((function(e){return e.value===t}))}function h(e){var t=e.queryString,n=void 0!==t&&t,r=e.groupId,a=(0,l.k6)(),i=function(e){var t=e.queryString,n=void 0!==t&&t,r=e.groupId;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=r?r:null}({queryString:n,groupId:r});return[(0,u._X)(i),(0,o.useCallback)((function(e){if(i){var t=new URLSearchParams(a.location.search);t.set(i,e),a.replace(Object.assign({},a.location,{search:t.toString()}))}}),[i,a])]}function k(e){var t,n,r,a,i=e.defaultValue,l=e.queryString,u=void 0!==l&&l,s=e.groupId,p=m(e),k=(0,o.useState)((function(){return function(e){var t,n=e.defaultValue,r=e.tabValues;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!c({value:n,tabValues:r}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+n+'" but none of its children has the corresponding value. Available values are: '+r.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return n}var o=null!=(t=r.find((function(e){return e.default})))?t:r[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:i,tabValues:p})})),f=k[0],g=k[1],b=h({queryString:u,groupId:s}),y=b[0],N=b[1],T=(t=function(e){return e?"docusaurus.tab."+e:null}({groupId:s}.groupId),n=(0,d.Nk)(t),r=n[0],a=n[1],[r,(0,o.useCallback)((function(e){t&&a.set(e)}),[t,a])]),v=T[0],C=T[1],I=function(){var e=null!=y?y:v;return c({value:e,tabValues:p})?e:null}();return(0,o.useLayoutEffect)((function(){I&&g(I)}),[I]),{selectedValue:f,selectValue:(0,o.useCallback)((function(e){if(!c({value:e,tabValues:p}))throw new Error("Can't select invalid tab value="+e);g(e),N(e),C(e)}),[N,C,p]),tabValues:p}}var f=n(2389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){var t=e.className,n=e.block,l=e.selectedValue,u=e.selectValue,s=e.tabValues,d=[],p=(0,i.o5)().blockElementScrollPositionUntilNextRender,m=function(e){var t=e.currentTarget,n=d.indexOf(t),r=s[n].value;r!==l&&(p(t),u(r))},c=function(e){var t,n=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":var r,o=d.indexOf(e.currentTarget)+1;n=null!=(r=d[o])?r:d[0];break;case"ArrowLeft":var a,i=d.indexOf(e.currentTarget)-1;n=null!=(a=d[i])?a:d[d.length-1]}null==(t=n)||t.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":n},t)},s.map((function(e){var t=e.value,n=e.label,i=e.attributes;return o.createElement("li",(0,r.Z)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:function(e){return d.push(e)},onKeyDown:c,onClick:m},i,{className:(0,a.Z)("tabs__item",g.tabItem,null==i?void 0:i.className,{"tabs__item--active":l===t})}),null!=n?n:t)})))}function y(e){var t=e.lazy,n=e.children,r=e.selectedValue,a=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){var i=a.find((function(e){return e.props.value===r}));return i?(0,o.cloneElement)(i,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},a.map((function(e,t){return(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==r})})))}function N(e){var t=k(e);return o.createElement("div",{className:(0,a.Z)("tabs-container",g.tabList)},o.createElement(b,(0,r.Z)({},e,t)),o.createElement(y,(0,r.Z)({},e,t)))}function T(e){var t=(0,f.Z)();return o.createElement(N,(0,r.Z)({key:String(t)},e))}},2590:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>u,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),i=(n(4866),n(5162),["components"]),l={title:"Authorization"},u=void 0,s={unversionedId:"graphql/authorization",id:"graphql/authorization",title:"Authorization",description:"The following section assumes you are familiar with authentication in nestjs.",source:"@site/docs/graphql/authorization.mdx",sourceDirName:"graphql",slug:"/graphql/authorization",permalink:"/nestjs-query/docs/graphql/authorization",draft:!1,editUrl:"https://github.com/tripss/nestjs-query/edit/master/documentation/docs/graphql/authorization.mdx",tags:[],version:"current",frontMatter:{title:"Authorization"},sidebar:"docs",previous:{title:"Hooks",permalink:"/nestjs-query/docs/graphql/hooks"},next:{title:"Aggregations",permalink:"/nestjs-query/docs/graphql/aggregations"}},d={},p=[{value:"Getting Started",id:"getting-started",level:2},{value:"@Authorize Decorator",id:"authorize-decorator",level:2},{value:"Relation Filtering",id:"relation-filtering",level:3},{value:"Customizing Relation Authorization",id:"customizing-relation-authorization",level:3},{value:"Custom Authorizer",id:"custom-authorizer",level:3},{value:"Using Authorizers In Your Resolver",id:"using-authorizers-in-your-resolver",level:2},{value:"@InjectAuthorizer Decorator",id:"injectauthorizer-decorator",level:2},{value:"Authorize depending on operation",id:"authorize-depending-on-operation",level:2},{value:"Complete Example",id:"complete-example",level:2}],m={toc:p},c="wrapper";function h(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)(c,(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"The following section assumes you are familiar with ",(0,a.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/techniques/authentication"},"authentication in nestjs"),".")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"nestjs-query")," provides authorization helpers out of the box to reduce the amount of boilerplate typically required."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"nestjs-query")," graphql package exposes decorators and options to allow the following"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Additional filtering for objects based on the graphql context."),(0,a.kt)("li",{parentName:"ul"},"Filtering relations based on the graphql context."),(0,a.kt)("li",{parentName:"ul"},"Low level authorization service support when your authorizer needs to use other services or additional information\nthat is not in the graphql context.")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"If you are looking to modify incoming requests based on the context, take a look at the ",(0,a.kt)("a",{parentName:"p",href:"/nestjs-query/docs/graphql/hooks"},"hooks documentation"))),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Authorization is invoked as the last step before calling the ",(0,a.kt)("inlineCode",{parentName:"p"},"QueryService"),".")),(0,a.kt)("h2",{id:"getting-started"},"Getting Started"),(0,a.kt)("p",null,"All examples assume you have a guard that adds a ",(0,a.kt)("inlineCode",{parentName:"p"},"user")," to the req on the context."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"type AuthenticatedUser = {\n  id: number;\n  username: string;\n};\n\ntype UserContext = {\n  req: {\n    user: AuthenticatedUser;\n  };\n};\n")),(0,a.kt)("p",null,"For the sake of this example we'll use a ",(0,a.kt)("inlineCode",{parentName:"p"},"JWTAuthGuard")," described in ",(0,a.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/techniques/authentication#implementing-passport-jwt"},"implementing passport jwt")," nestjs docs."),(0,a.kt)("p",null,"To enable the guard on your resolver endpoints you use the ",(0,a.kt)("inlineCode",{parentName:"p"},"guards")," option when setting up your resolver."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"guards")," option will ensure that all queries and mutations will have the ",(0,a.kt)("inlineCode",{parentName:"p"},"guard")," added so the user is added to\nthe request."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todo-item/todo-item.module.ts" {19}',title:'"todo-item/todo-item.module.ts"',"{19}":!0},"import { NestjsQueryGraphQLModule } from '@ptc-org/nestjs-query-graphql';\nimport { NestjsQueryTypeOrmModule } from '@ptc-org/nestjs-query-typeorm';\nimport { Module } from '@nestjs/common';\nimport { TodoItemInputDTO } from './dto/todo-item-input.dto';\nimport { TodoItemUpdateDTO } from './dto/todo-item-update.dto';\nimport { TodoItemDTO } from './dto/todo-item.dto';\nimport { TodoItemEntity } from './todo-item.entity';\nimport { JwtAuthGuard } from '../auth/jwt-auth.guard';\n\n@Module({\n  imports: [\n    NestjsQueryGraphQLModule.forFeature({\n      imports: [NestjsQueryTypeOrmModule.forFeature([TodoItemEntity])],\n      resolvers: [\n        {\n          DTOClass: TodoItemDTO,\n          CreateDTOClass: TodoItemInputDTO,\n          UpdateDTOClass: TodoItemUpdateDTO,\n          guards: [JwtAuthGuard],\n        },\n      ],\n    }),\n  ],\n})\nexport class TodoItemModule {}\n")),(0,a.kt)("h2",{id:"authorize-decorator"},"@Authorize Decorator"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"@ptc-org/nestjs-query-graphql")," package includes an ",(0,a.kt)("inlineCode",{parentName:"p"},"@Authorize")," decorator that allows you to add additional filter\ncriteria to authorize an incoming request."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"@Authorize")," decorator accepts the following types."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"An ",(0,a.kt)("inlineCode",{parentName:"li"},"object")," that has an ",(0,a.kt)("inlineCode",{parentName:"li"},"authorize")," method that returns a Filter for the DTO."),(0,a.kt)("li",{parentName:"ul"},"An instance of an ",(0,a.kt)("inlineCode",{parentName:"li"},"Authorizer")," that implements the ",(0,a.kt)("inlineCode",{parentName:"li"},"authorize")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"authorizeRelation")," methods."),(0,a.kt)("li",{parentName:"ul"},"An ",(0,a.kt)("inlineCode",{parentName:"li"},"Authorizer")," class reference that implements the ",(0,a.kt)("inlineCode",{parentName:"li"},"Authorizer")," interface. The ",(0,a.kt)("inlineCode",{parentName:"li"},"Authorizer")," class will be\ninstantiated using the ",(0,a.kt)("inlineCode",{parentName:"li"},"nestjs"),"'s dependency injection.")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"@Authorize")," decorator does not return an unauthorized error instead the following will occur:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"queryMany")," results will not include any DTOs that do not match the filter criteria."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"findOne")," will return a not found for a DTO that cannot be found for the ",(0,a.kt)("inlineCode",{parentName:"li"},"id")," and auth filter."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"updateOne")," will return a not found error if the DTO to update cannot be found for the ",(0,a.kt)("inlineCode",{parentName:"li"},"id")," and auth filter."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"updateMany")," will exclude any records that do not match the user provided filter and the auth filter from being\nupdated."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"deleteOne")," will return a not found error if the DTO to delete cannot be found for the ",(0,a.kt)("inlineCode",{parentName:"li"},"id")," and auth filter."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"deleteMany")," will exclude any records that do not match the user provided filter and the auth filter from being\ndeleted.")),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"You can throw an ",(0,a.kt)("inlineCode",{parentName:"p"},"UnauthorizedException")," or return a rejected promise with an ",(0,a.kt)("inlineCode",{parentName:"p"},"UnauthorizedException")," in your\nauthorize function, if you can determine at that point that the user should not be able to access the endpoint.")),(0,a.kt)("p",null,"In the following example the ",(0,a.kt)("inlineCode",{parentName:"p"},"authorize")," function returns a ",(0,a.kt)("inlineCode",{parentName:"p"},"Filter")," that includes the ",(0,a.kt)("inlineCode",{parentName:"p"},"ownerId")," to ensure that only\n",(0,a.kt)("inlineCode",{parentName:"p"},"TodoItems")," that belong to the authenticated user are returned."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todo-item/dto/todo-item.dto.ts" {15}',title:'"todo-item/dto/todo-item.dto.ts"',"{15}":!0},"import {\n  FilterableField,\n  IDField,\n  FilterableConnection,\n  FilterableRelation,\n  Authorize\n} from '@ptc-org/nestjs-query-graphql';\nimport { ObjectType, ID, GraphQLISODateTime, Field } from '@nestjs/graphql';\nimport { SubTaskDTO } from '../../sub-task/dto/sub-task.dto';\nimport { TagDTO } from '../../tag/dto/tag.dto';\nimport { UserDTO } from '../../user/user.dto';\nimport { UserContext } from '../../auth/auth.interfaces';\n\n@ObjectType('TodoItem')\n@Authorize({ authorize: (context: UserContext) => ({ ownerId: { eq: context.req.user.id } }) })\n@FilterableRelation('owner', () => UserDTO)\n@FilterableConnection('subTasks', () => SubTaskDTO, { update: { enabled: true } })\n@FilterableConnection('tags', () => TagDTO)\nexport class TodoItemDTO {\n  @IDField(() => ID)\n  id!: number;\n\n  @FilterableField()\n  title!: string;\n\n  @FilterableField({ nullable: true })\n  description?: string;\n\n  @FilterableField()\n  completed!: boolean;\n\n  @FilterableField(() => GraphQLISODateTime)\n  created!: Date;\n\n  @FilterableField(() => GraphQLISODateTime)\n  updated!: Date;\n\n  @Field()\n  age!: number;\n\n  @FilterableField()\n  priority!: number;\n\n  @FilterableField({ nullable: true })\n  createdBy?: string;\n\n  @FilterableField({ nullable: true })\n  updatedBy?: string;\n\n  @FilterableField()\n  ownerId!: number;\n}\n")),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"The above example is pretty straight forward, however your authorize function can be as complex as you need it to be\nbased on information in the context.")),(0,a.kt)("h3",{id:"relation-filtering"},"Relation Filtering"),(0,a.kt)("p",null,"By default when relations are queried any additional filters defined using the ",(0,a.kt)("inlineCode",{parentName:"p"},"@Authorize")," decorator on the relation\nDTO will also be included."),(0,a.kt)("p",null,"When mutating relations"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If the DTO that is having a relation(s) added or removed cannot be found for the ",(0,a.kt)("inlineCode",{parentName:"li"},"id")," and\nauth filter a not found error will be returned."),(0,a.kt)("li",{parentName:"ul"},"When adding or removing a single relation if the relation cannot be found for the ",(0,a.kt)("inlineCode",{parentName:"li"},"id")," and auth filter a not found\nerror will be returned."),(0,a.kt)("li",{parentName:"ul"},"When adding or removing multiple relations if all relations cannot be found a not found error will be throw.")),(0,a.kt)("p",null,"For example given the following ",(0,a.kt)("inlineCode",{parentName:"p"},"SubTaskDTO")," definition whenever the ",(0,a.kt)("inlineCode",{parentName:"p"},"subTasks")," connection is queried through a\n",(0,a.kt)("inlineCode",{parentName:"p"},"todoItem"),", only ",(0,a.kt)("inlineCode",{parentName:"p"},"subTasks")," that belong to the user will be returned."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="sub-task/dto/sub-task.dto.ts"',title:'"sub-task/dto/sub-task.dto.ts"'},"import { FilterableField, IDField, FilterableRelation, Authorize } from '@ptc-org/nestjs-query-graphql';\nimport { ObjectType, ID, GraphQLISODateTime } from '@nestjs/graphql';\nimport { TodoItemDTO } from '../../todo-item/dto/todo-item.dto';\nimport { UserContext } from '../../auth/auth.interfaces';\n\n@ObjectType('SubTask')\n@Authorize({ authorize: (context: UserContext) => ({ ownerId: { eq: context.req.user.id } }) })\n@FilterableRelation('todoItem', () => TodoItemDTO, { update: { enabled: true } })\nexport class SubTaskDTO {\n  @IDField(() => ID)\n  id!: number;\n\n  @FilterableField()\n  title!: string;\n\n  @FilterableField({ nullable: true })\n  description?: string;\n\n  @FilterableField()\n  completed!: boolean;\n\n  @FilterableField(() => GraphQLISODateTime)\n  created!: Date;\n\n  @FilterableField(() => GraphQLISODateTime)\n  updated!: Date;\n\n  @FilterableField()\n  todoItemId!: string;\n\n  @FilterableField({ nullable: true })\n  createdBy?: string;\n\n  @FilterableField({ nullable: true })\n  updatedBy?: string;\n}\n")),(0,a.kt)("h3",{id:"customizing-relation-authorization"},"Customizing Relation Authorization"),(0,a.kt)("p",null,"If you run into a case where you need to handle authorization for a relation differently from the ",(0,a.kt)("inlineCode",{parentName:"p"},"@Authorize"),"\ndecorator on the relation DTO you can specify the ",(0,a.kt)("inlineCode",{parentName:"p"},"auth")," option in your relation/connection decorator."),(0,a.kt)("admonition",{type:"warning"},(0,a.kt)("p",{parentName:"admonition"},"The ",(0,a.kt)("inlineCode",{parentName:"p"},"auth")," option will take precedence over the ",(0,a.kt)("inlineCode",{parentName:"p"},"@Authorize")," decorator on the relation DTO.")),(0,a.kt)("p",null,"For example you could define the subtasks with the ",(0,a.kt)("inlineCode",{parentName:"p"},"auth")," option, only allowing completed subtasks to be returned."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@FilterableConnection('subTasks', () => SubTaskDTO, {\n  update: { enabled: true },\n  auth: {\n    authorize: (context: UserContext) => ({ ownerId: { eq: context.req.user.id }, completed: { is: true }}),\n  },\n})\n")),(0,a.kt)("h3",{id:"custom-authorizer"},"Custom Authorizer"),(0,a.kt)("p",null,"When you need more control over authorization you can create a ",(0,a.kt)("inlineCode",{parentName:"p"},"CustomAuthorizer"),". You may want to use a\n",(0,a.kt)("inlineCode",{parentName:"p"},"CustomAuthorizer")," if you need to use additional services to do authorization for a DTO."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"CustomAuthorizer")," interface ensures two methods:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"authorize")," - Should return a filter that should be used for all queries and mutations for the DTO."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"authorizeRelation")," - Optionally modify the filter for the relation that will be used when querying the relation or\nadding/removing relations to/from the DTO. If undefined is returned, the authorization filter of the relation DTO\nwill be used instead.")),(0,a.kt)("p",null,"In this example we'll create a simple authorizer for ",(0,a.kt)("inlineCode",{parentName:"p"},"SubTasks"),". You can use this as a base to create a more complex\nauthorizers that depends on other services."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title='sub-task/sub-task.authorizer.ts'",title:"'sub-task/sub-task.authorizer.ts'"},"import { Injectable } from '@nestjs/common';\nimport { Authorizer } from '@ptc-org/nestjs-query-graphql';\nimport { Filter } from '@ptc-org/nestjs-query-core';\nimport { UserContext } from '../auth/auth.interfaces';\nimport { SubTaskDTO } from './dto/sub-task.dto';\n\n@Injectable()\nexport class SubTaskAuthorizer implements CustomAuthorizer<SubTaskDTO> {\n  authorize(context: UserContext): Promise<Filter<SubTaskDTO>> {\n    return Promise.resolve({ ownerId: { eq: context.req.user.id } });\n  }\n\n  authorizeRelation(relationName: string, context: UserContext): Promise<Filter<unknown> | undefined> {\n    if (relationName === 'todoItem') {\n      return Promise.resolve({ ownerId: { eq: context.req.user.id } });\n    }\n    return Promise.resolve(undefined);\n  }\n}\n")),(0,a.kt)("p",null,"To use the ",(0,a.kt)("inlineCode",{parentName:"p"},"SubTaskAuthorizer")," you only need to provide it as an argument to the ",(0,a.kt)("inlineCode",{parentName:"p"},"@Authorize")," decorator"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title='sub-task/sub-task.dto.ts' {8}",title:"'sub-task/sub-task.dto.ts'","{8}":!0},"import { Authorize, FilterableField, IDField, FilterableRelation } from '@ptc-org/nestjs-query-graphql';\nimport { ObjectType, ID, GraphQLISODateTime } from '@nestjs/graphql';\nimport { TodoItemDTO } from '../../todo-item/dto/todo-item.dto';\nimport { UserDTO } from '../../user/user.dto';\nimport { SubTaskAuthorizer } from '../sub-task.authorizer';\n\n@ObjectType('SubTask')\n@Authorize(SubTaskAuthorizer)\n@FilterableRelation('owner', () => UserDTO)\n@FilterableRelation('todoItem', () => TodoItemDTO, { update: { enabled: true } })\nexport class SubTaskDTO {\n  @IDField(() => ID)\n  id!: number;\n\n  @FilterableField()\n  title!: string;\n\n  @FilterableField({ nullable: true })\n  description?: string;\n\n  @FilterableField()\n  completed!: boolean;\n\n  @FilterableField(() => GraphQLISODateTime)\n  created!: Date;\n\n  @FilterableField(() => GraphQLISODateTime)\n  updated!: Date;\n\n  @FilterableField()\n  todoItemId!: string;\n\n  @FilterableField({ nullable: true })\n  createdBy?: string;\n\n  @FilterableField({ nullable: true })\n  updatedBy?: string;\n\n  ownerId!: number;\n}\n")),(0,a.kt)("h2",{id:"using-authorizers-in-your-resolver"},"Using Authorizers In Your Resolver"),(0,a.kt)("p",null,"The easiest way to leverage ",(0,a.kt)("inlineCode",{parentName:"p"},"Authorizers")," in a custom resolver is to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthorizerInterceptor")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"AuthorizerFilter")," param decorator."),(0,a.kt)("p",null,"In this example there are two important additions:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"AuthorizerInterceptor")," is added to the ",(0,a.kt)("inlineCode",{parentName:"li"},"TodoItemResolver")," as an interceptor, this interceptor will add the\nauthorizer to the context so it can be used down stream"),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"AuthorizerFilter")," param decorator uses the authorizer added by the interceptor to create an authorizer filter.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todo-item/todo-item.resolver.ts" {9,17}',title:'"todo-item/todo-item.resolver.ts"',"{9,17}":!0},"import { Filter, InjectQueryService, mergeFilter, mergeQuery, QueryService } from '@ptc-org/nestjs-query-core';\nimport { AuthorizerInterceptor, AuthorizerFilter, ConnectionType } from '@ptc-org/nestjs-query-graphql';\nimport { Args, Query, Resolver } from '@nestjs/graphql';\nimport { UseInterceptors } from '@nestjs/common';\nimport { TodoItemDTO } from './dto/todo-item.dto';\nimport { TodoItemConnection, TodoItemQuery } from './types';\n\n@Resolver(() => TodoItemDTO)\n@UseInterceptors(AuthorizerInterceptor(TodoItemDTO))\nexport class TodoItemResolver {\n  constructor(@InjectQueryService(TodoItemEntity) readonly service: QueryService<TodoItemEntity>) {}\n\n  // Set the return type to the TodoItemConnection\n  @Query(() => TodoItemConnection)\n  async uncompletedTodoItems(\n    @Args() query: TodoItemQuery,\n    @AuthorizerFilter() authFilter: Filter<TodoItemDTO>,\n  ): Promise<ConnectionType<TodoItemDTO>> {\n    // add the completed filter the user provided filter\n    const filter: Filter<TodoItemDTO> = mergeFilter(query.filter ?? {}, { completed: { is: false } });\n    const uncompletedQuery = mergeQuery(query, { filter: mergeFilter(filter, authFilter) });\n    return TodoItemConnection.createFromPromise(\n      (q) => this.service.query(q),\n      uncompletedQuery,\n      (q) => this.service.count(q),\n    );\n  }\n}\n")),(0,a.kt)("h2",{id:"injectauthorizer-decorator"},"@InjectAuthorizer Decorator"),(0,a.kt)("p",null,"If you need access to an authorizer for a DTO you can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"@InjectAuthorizer")," decorator."),(0,a.kt)("p",null,"The most common use case for using the ",(0,a.kt)("inlineCode",{parentName:"p"},"@InjectAuthorizer")," decorator is when you are not using the autogenerated\nresolvers provided by ",(0,a.kt)("inlineCode",{parentName:"p"},"nestjs-query"),"."),(0,a.kt)("p",null,"In this example the ",(0,a.kt)("inlineCode",{parentName:"p"},"Authorizer")," is injected as a ",(0,a.kt)("inlineCode",{parentName:"p"},"readonly")," property you can then use it for any custom methods."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="todo-item/todo-item.resolver.ts"',title:'"todo-item/todo-item.resolver.ts"'},"import { QueryService, InjectQueryService } from '@ptc-org/nestjs-query-core';\nimport { CRUDResolver, InjectAuthorizer } from '@ptc-org/nestjs-query-graphql';\nimport { Resolver, Query, Args } from '@nestjs/graphql';\nimport { TodoItemDTO } from './dto/todo-item.dto';\nimport { TodoItemEntity } from './todo-item.entity';\n\n@Resolver(() => TodoItemDTO)\nexport class TodoItemResolver extends CRUDResolver(TodoItemDTO) {\n  constructor(\n    @InjectQueryService(TodoItemEntity) readonly service: QueryService<TodoItemEntity>,\n    @InjectAuthorizer(TodoItemDTO) readonly authorizer: Authorizer<TodoItemDTO>,\n  ) {\n    super(service);\n  }\n}\n")),(0,a.kt)("admonition",{type:"important"},(0,a.kt)("p",{parentName:"admonition"},"If you are extending the ",(0,a.kt)("inlineCode",{parentName:"p"},"CRUDResolver")," directly be sure to ",(0,a.kt)("a",{parentName:"p",href:"/nestjs-query/docs/graphql/resolvers#crudresolver"},"register your DTOs with the ",(0,a.kt)("inlineCode",{parentName:"a"},"NestjsQueryGraphQLModule")))),(0,a.kt)("admonition",{type:"important"},(0,a.kt)("p",{parentName:"admonition"},"When using ",(0,a.kt)("inlineCode",{parentName:"p"},"@InjectAuthorizer"),", the injected Authorizer is not the CustomAuthorizer, but the DefaultCRUDAuthorizer that internally uses the CustomAuthorizer.\nIf you want to use the CustomAuthorizer directly, inject it with ",(0,a.kt)("inlineCode",{parentName:"p"},"@InjectCustomAuthorizer")," instead.")),(0,a.kt)("h2",{id:"authorize-depending-on-operation"},"Authorize depending on operation"),(0,a.kt)("p",null,"Sometimes it might be necessary to perform different authorization based on the kind of operation an user wants to execute.\nE.g. some users could be allowed to read all todo items but only update/delete their own."),(0,a.kt)("p",null,"In this case we can make use of the second parameter of the ",(0,a.kt)("inlineCode",{parentName:"p"},"authorize")," function in our ",(0,a.kt)("inlineCode",{parentName:"p"},"CustomAuthorizer")," or the one passed to the ",(0,a.kt)("inlineCode",{parentName:"p"},"@Authorizer")," decorator which gets passed additional ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthorizationContext")," such as the name of the operation that should be authorized:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title='sub-task/sub-task.authorizer.ts'",title:"'sub-task/sub-task.authorizer.ts'"},"import { Injectable } from '@nestjs/common';\nimport { CustomAuthorizer } from '@ptc-org/nestjs-query-graphql';\nimport { Filter } from '@ptc-org/nestjs-query-core';\nimport { UserContext } from '../auth/auth.interfaces';\nimport { SubTaskDTO } from './dto/sub-task.dto';\n\n@Injectable()\nexport class SubTaskAuthorizer implements CustomAuthorizer<SubTaskDTO> {\n  authorize(context: UserContext, authorizationContext?: AuthorizationContext): Promise<Filter<SubTaskDTO>> {\n    if (authorizationContext?.readonly) {\n      return Promise.resolve({});\n    }\n\n    return Promise.resolve({ ownerId: { eq: context.req.user.id } });\n  }\n\n  authorizeRelation(relationName: string, context: UserContext): Promise<Filter<unknown>> {\n    if (relationName === 'todoItem') {\n      return Promise.resolve({ ownerId: { eq: context.req.user.id } });\n    }\n    return Promise.resolve({});\n  }\n}\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthorizationContext")," has the following shape:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title='authorizer.ts'",title:"'authorizer.ts'"},"export enum OperationGroup {\n  READ = 'read',\n  AGGREGATE = 'aggregate',\n  CREATE = 'create',\n  UPDATE = 'update',\n  DELETE = 'delete',\n}\n\ninterface AuthorizationContext {\n  /** The name of the method that uses the @AuthorizeFilter decorator */\n  operationName: string;\n\n  /** The group this operation belongs to */\n  operationGroup: OperationGroup;\n\n  /** If the operation does not modify any entities */\n  readonly: boolean;\n\n  /** If the operation can affect multiple entities */\n  many: boolean;\n}\n")),(0,a.kt)("p",null,"This context is automatically created for you when using the built-in resolvers.\nIf you authorize custom methods by using the ",(0,a.kt)("inlineCode",{parentName:"p"},"@AuthorizerFilter()"),", you should pass the context as argument to the decorator:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@AuthorizerFilter({\n  operationName: 'completedTodoItems',\n  operationGroup: OperationGroup.READ,\n  readonly: true,\n  many: true\n})\n")),(0,a.kt)("p",null,"You can leave out the ",(0,a.kt)("inlineCode",{parentName:"p"},"operationName")," to let the context use the name of the decorated Method.\nIf you leave out the ",(0,a.kt)("inlineCode",{parentName:"p"},"readonly")," property, it's inferred from the ",(0,a.kt)("inlineCode",{parentName:"p"},"operationGroup"),"."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"operationNames")," of the generated CRUD resolver methods are similar to the ones of the ",(0,a.kt)("a",{parentName:"p",href:"/nestjs-query/docs/concepts/services"},"QueryService"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"queryMany")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"findById")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"aggregate")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"createOne")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"createMany")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"updateOne")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"updateMany")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"deleteOne")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"deleteMany"))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Relations")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"query{PluralRelationName}")," (e.g. querySubTasks)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"find{SingularRelationName}")," (e.g. findTodoItem)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"aggregate{PluralRelationName}")," (e.g. aggregateSubTasks)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"remove{SingularRelationName}from{SingularParentName}")," (e.g. removeSubTaskFromTodoItem)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"remove{PluralRelationName}from{SingularParentName}")," (e.g. removeSubTasksFromTodoItem)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"set{SingularRelationName}On{SingularParentName}")," (e.g. setSubTaskOnTodoItem)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"add{PluralRelationName}On{SingularParentName}")," (e.g. addSubTasksOnTodoItem)")),(0,a.kt)("h2",{id:"complete-example"},"Complete Example"),(0,a.kt)("p",null,"You can find a complete example in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/tripss/nestjs-query/tree/master/examples/auth"},(0,a.kt)("inlineCode",{parentName:"a"},"examples/auth"))))}h.isMDXComponent=!0}}]);